import pandas as pd
from pykeen.pipeline import pipeline
from pykeen.triples import TriplesFactory
from pykeen.evaluation import RankBasedEvaluator
from torch.nn.init import xavier_normal_
import numpy as np
import pickle
import argparse
import os
import tensorflow as tf

from utils.embedding import CustomEmbeddingModel

# function for extracting best parameters from an optuna trials data frame
def extract_best_params(df, score_col = 'user_attrs_both.realistic.adjusted_arithmetic_mean_rank_index'):

    sorted_scores = df.sort_values(score_col, ascending = False)
    top_model = sorted_scores.iloc[0, sorted_scores.columns.str.contains('params')]
    top_model.index = top_model.index.str.replace('^params_', '', regex = True)
    
    if top_model.index.str.contains('\.').any():
        param_types = top_model.index.str.replace('\..+$', '', regex = True)
        param_names = top_model.index.str.replace('^.+\.', '', regex = True)
        param_values = top_model.values
        params = {}
        for ptype, pname, value in zip(param_types, param_names, param_values):
            argname = ptype + '_kwargs'
            if argname not in params:
                params[argname] = {}
            params[argname][pname] = value.item()
            
        params['training_kwargs']['batch_size'] = int(params['training_kwargs']['batch_size'])
        params['training_kwargs']['num_epochs'] = 50
        params['model_kwargs']['entity_initializer'] = xavier_normal_
        params['model_kwargs']['relation_initializer'] = xavier_normal_
        params['negative_sampler_kwargs'] = {}
        params['negative_sampler_kwargs']['num_negs_per_pos'] = 5
            
    else:
        param_names = top_model.index
        param_values = top_model.values
        params = {name: v.item() for name, v in zip(param_names, param_values)}
        
    return params

if __name__ == '__main__':

    parser = argparse.ArgumentParser()
    parser.add_argument('json', type = str, help = 'Path to graph json file, generated by Neo4j')
    parser.add_argument('-o', '--outdir', type = str, default = None, help = 'Filepath where model output should be saved')
    parser.add_argument('-t', '--test_size', type = float, default = 0.1, help = 'Proportion of facts allocated to test set')
    parser.add_argument('-v', '--validation_size', type = float, default = 0.1, help = 'Proportion of facts allocated to validation set')
    args = parser.parse_args()
    
    if args.outdir is not None:
        outdir = args.outdir + '/' if args.outdir[-1] != '/' else args.outdir
    else:
        outdir = ''

    gpus = tf.config.list_physical_devices('GPU')
    
    os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'
        
    transE_trials_path = 'data/hyperparams/transE_trials.tsv'
    transR_trials_path = 'data/hyperparams/transR_trials.tsv'
    convE_trials_path = 'data/hyperparams/convE_trials.tsv'
    complEx_trials_path = 'data/hyperparams/complEx_trials.tsv'
    custom_trials_path = 'data/hyperparams/custom_trials.tsv'
    
    pykeen_triples_outpath = 'pykeen_all_triples.p'
    
    transE_outpath = 'transE_model.p'
    transR_outpath = 'transR_model.p'
    convE_outpath = 'convE_model.p'
    complEx_outpath = 'complEx_model.p'
    custom_outpath = 'custom_model.p'
    
    pykeen_train_outpath = 'pykeen_train.tsv'
    pykeen_test_outpath = 'pykeen_test.tsv'
    custom_train_outpath = 'custom_train.tsv'
    custom_test_outpath = 'custom_test.tsv'
    
    model = CustomEmbeddingModel(args.json, state = 123)
        
    pykeen_facts = model.embedding_data.drop_duplicates(['head_lab', 'general_relation_lab', 'tail_lab'])
        
    # train/test split
    model.split(pykeen_facts, 
                test_size = args.test_size, 
                validation_size = args.validation_size,
                stratify_column = 'general_relation_lab', 
                state = 123)
    
    pykeen_all, pykeen_train, pykeen_test = model.embedding_facts, model.final_train_set, model.test_set
    
    # masks for different types of facts in the pykeen test set
    pathway_rel_mask = pykeen_test['general_relation_lab'] != pykeen_test['specific_relation_lab']
    TF_binding_rel_mask = pykeen_test['general_relation_lab'] == 'TF_BINDING'
    GO_gene_term_mask = np.logical_xor(pykeen_test['head_type'] == 'GeneOntologyTerm', pykeen_test['tail_type'] == 'GeneOntologyTerm')
    GO_term_term_mask = (pykeen_test['head_type'] == 'GeneOntologyTerm') & (pykeen_test['tail_type'] == 'GeneOntologyTerm')
    physical_interaction_mask = pykeen_test['general_relation_lab'] == 'PHYSICAL_INTERACTION'
 
    # convert train/test sets to numpy array, as well as all fact subsets
    pykeen_all_numpy = pykeen_all[['head_lab', 'general_relation_lab', 'tail_lab']].to_numpy(dtype = 'str')
    pykeen_train_numpy = pykeen_train[['head_lab', 'general_relation_lab', 'tail_lab']].to_numpy(dtype = 'str')
    pykeen_test_numpy = pykeen_test[['head_lab', 'general_relation_lab', 'tail_lab']].to_numpy(dtype = 'str')
    pykeen_test_pathway_numpy = pykeen_test[pathway_rel_mask][['head_lab', 'general_relation_lab', 'tail_lab']].to_numpy(dtype = 'str')
    pykeen_test_TF_numpy = pykeen_test[TF_binding_rel_mask][['head_lab', 'general_relation_lab', 'tail_lab']].to_numpy(dtype = 'str')
    pykeen_test_GO_gene_numpy = pykeen_test[GO_gene_term_mask][['head_lab', 'general_relation_lab', 'tail_lab']].to_numpy(dtype = 'str')
    pykeen_test_GO_term_numpy = pykeen_test[GO_term_term_mask][['head_lab', 'general_relation_lab', 'tail_lab']].to_numpy(dtype = 'str')
    pykeen_test_physint_numpy = pykeen_test[physical_interaction_mask][['head_lab', 'general_relation_lab', 'tail_lab']].to_numpy(dtype = 'str')

    # create triples for pykeen
    pykeen_all_triples = TriplesFactory.from_labeled_triples(pykeen_all_numpy, 
                                                             create_inverse_triples = False,
                                                             entity_to_id = model.embedding_node_lab2idx, 
                                                             relation_to_id = model.embedding_gen_rel_lab2idx)
    pykeen_train_triples = TriplesFactory.from_labeled_triples(pykeen_train_numpy, 
                                                               create_inverse_triples = False,
                                                               entity_to_id = model.embedding_node_lab2idx, 
                                                               relation_to_id = model.embedding_gen_rel_lab2idx)
    pykeen_test_triples = TriplesFactory.from_labeled_triples(pykeen_test_numpy,
                                                              create_inverse_triples = False,
                                                              entity_to_id = model.embedding_node_lab2idx, 
                                                              relation_to_id = model.embedding_gen_rel_lab2idx)
    pykeen_pathway_test_triples = TriplesFactory.from_labeled_triples(pykeen_test_pathway_numpy,
                                                                      create_inverse_triples = False,
                                                                      entity_to_id = model.embedding_node_lab2idx, 
                                                                      relation_to_id = model.embedding_gen_rel_lab2idx)
    pykeen_TF_test_triples = TriplesFactory.from_labeled_triples(pykeen_test_TF_numpy,
                                                                 create_inverse_triples = False,
                                                                 entity_to_id = model.embedding_node_lab2idx, 
                                                                 relation_to_id = model.embedding_gen_rel_lab2idx)
    pykeen_GO_gene_test_triples = TriplesFactory.from_labeled_triples(pykeen_test_GO_gene_numpy,
                                                                      create_inverse_triples = False,
                                                                      entity_to_id = model.embedding_node_lab2idx, 
                                                                      relation_to_id = model.embedding_gen_rel_lab2idx)
    pykeen_GO_term_test_triples = TriplesFactory.from_labeled_triples(pykeen_test_GO_term_numpy,
                                                                      create_inverse_triples = False,
                                                                      entity_to_id = model.embedding_node_lab2idx, 
                                                                      relation_to_id = model.embedding_gen_rel_lab2idx)
    pykeen_physint_test_triples = TriplesFactory.from_labeled_triples(pykeen_test_physint_numpy,
                                                                      create_inverse_triples = False,
                                                                      entity_to_id = model.embedding_node_lab2idx, 
                                                                      relation_to_id = model.embedding_gen_rel_lab2idx)
    
    # save the triples factory for all triples
    pickle.dump(pykeen_all_triples, open(outdir + pykeen_triples_outpath, 'wb'))
    
    # initialise evaluator class
    evaluator = RankBasedEvaluator()
    
    # import HP search results 
    transE_hp_trials = pd.read_csv(transE_trials_path, sep = '\t')
    transE_best_params = extract_best_params(transE_hp_trials)
    transR_hp_trials = pd.read_csv(transR_trials_path, sep = '\t')
    transR_best_params = extract_best_params(transR_hp_trials)
    convE_hp_trials = pd.read_csv(convE_trials_path, sep = '\t')
    convE_best_params = extract_best_params(convE_hp_trials)
    complEx_hp_trials = pd.read_csv(complEx_trials_path, sep = '\t')
    complEx_best_params = extract_best_params(complEx_hp_trials)
    
    # fit models, save pickles
    transE = pipeline(
        training = pykeen_train_triples,
        testing = pykeen_test_triples,
        model = 'TransE',
        loss = 'MarginRankingLoss',
        optimizer = 'Adam',
        negative_sampler = 'Bernoulli',
        training_loop = 'sLCWA',
        random_seed = 123,
        **transE_best_params
    )
    transE_pathway_evaluation = evaluator.evaluate(model = transE.model,
                                                   mapped_triples = pykeen_pathway_test_triples.mapped_triples,
                                                   additional_filter_triples = [pykeen_train_triples.mapped_triples])
    transE_TF_evaluation = evaluator.evaluate(model = transE.model,
                                              mapped_triples = pykeen_TF_test_triples.mapped_triples,
                                              additional_filter_triples = [pykeen_train_triples.mapped_triples])
    transE_GO_gene_evaluation = evaluator.evaluate(model = transE.model,
                                                   mapped_triples = pykeen_GO_gene_test_triples.mapped_triples,
                                                   additional_filter_triples = [pykeen_train_triples.mapped_triples])
    transE_GO_term_evaluation = evaluator.evaluate(model = transE.model,
                                                   mapped_triples = pykeen_GO_term_test_triples.mapped_triples,
                                                   additional_filter_triples = [pykeen_train_triples.mapped_triples])
    transE_physint_evaluation = evaluator.evaluate(model = transE.model,
                                                   mapped_triples = pykeen_physint_test_triples.mapped_triples,
                                                   additional_filter_triples = [pykeen_train_triples.mapped_triples])
    
    transE_results = {'model': transE.model,
                      'amri': transE.get_metric('adjusted_arithmetic_mean_rank_index'),
                      'amri_pathway_relations': transE_pathway_evaluation.get_metric('adjusted_arithmetic_mean_rank_index'),
                      'amri_TF_relations': transE_TF_evaluation.get_metric('adjusted_arithmetic_mean_rank_index'),
                      'amri_GO_gene_term_relations': transE_GO_gene_evaluation.get_metric('adjusted_arithmetic_mean_rank_index'),
                      'amri_GO_term_term_relations': transE_GO_term_evaluation.get_metric('adjusted_arithmetic_mean_rank_index'),
                      'amri_physical_int_relations': transE_physint_evaluation.get_metric('adjusted_arithmetic_mean_rank_index')}
    
    pickle.dump(transE_results, open(outdir + transE_outpath, 'wb'))
    
    transR = pipeline(
        training = pykeen_train_triples,
        testing = pykeen_test_triples,
        model = 'TransR',
        loss = 'MarginRankingLoss',
        optimizer = 'Adam',
        negative_sampler = 'Bernoulli',
        training_loop = 'sLCWA',
        random_seed = 123,
        **transR_best_params
    )
    transR_pathway_evaluation = evaluator.evaluate(model = transR.model,
                                                   mapped_triples = pykeen_pathway_test_triples.mapped_triples,
                                                   additional_filter_triples = [pykeen_train_triples.mapped_triples])
    transR_TF_evaluation = evaluator.evaluate(model = transR.model,
                                              mapped_triples = pykeen_TF_test_triples.mapped_triples,
                                              additional_filter_triples = [pykeen_train_triples.mapped_triples])
    transR_GO_gene_evaluation = evaluator.evaluate(model = transR.model,
                                                   mapped_triples = pykeen_GO_gene_test_triples.mapped_triples,
                                                   additional_filter_triples = [pykeen_train_triples.mapped_triples])
    transR_GO_term_evaluation = evaluator.evaluate(model = transR.model,
                                                   mapped_triples = pykeen_GO_term_test_triples.mapped_triples,
                                                   additional_filter_triples = [pykeen_train_triples.mapped_triples])
    transR_physint_evaluation = evaluator.evaluate(model = transR.model,
                                                   mapped_triples = pykeen_physint_test_triples.mapped_triples,
                                                   additional_filter_triples = [pykeen_train_triples.mapped_triples])
    
    transR_results = {'model': transR.model,
                      'amri': transR.get_metric('adjusted_arithmetic_mean_rank_index'),
                      'amri_pathway_relations': transR_pathway_evaluation.get_metric('adjusted_arithmetic_mean_rank_index'),
                      'amri_TF_relations': transR_TF_evaluation.get_metric('adjusted_arithmetic_mean_rank_index'),
                      'amri_GO_gene_term_relations': transR_GO_gene_evaluation.get_metric('adjusted_arithmetic_mean_rank_index'),
                      'amri_GO_term_term_relations': transR_GO_term_evaluation.get_metric('adjusted_arithmetic_mean_rank_index'),
                      'amri_physical_int_relations': transR_physint_evaluation.get_metric('adjusted_arithmetic_mean_rank_index')}
    
    pickle.dump(transR_results, open(outdir + transR_outpath, 'wb'))
    
    convE = pipeline(
        training = pykeen_train_triples,
        testing = pykeen_test_triples,
        model = 'ConvE',
        loss = 'MarginRankingLoss',
        optimizer = 'Adam',
        negative_sampler = 'Bernoulli',
        training_loop = 'sLCWA',
        random_seed = 123,
        **convE_best_params
    )
    convE_pathway_evaluation = evaluator.evaluate(model = convE.model,
                                                  mapped_triples = pykeen_pathway_test_triples.mapped_triples,
                                                  additional_filter_triples = [pykeen_train_triples.mapped_triples])
    convE_TF_evaluation = evaluator.evaluate(model = convE.model,
                                             mapped_triples = pykeen_TF_test_triples.mapped_triples,
                                             additional_filter_triples = [pykeen_train_triples.mapped_triples])
    convE_GO_gene_evaluation = evaluator.evaluate(model = convE.model,
                                                  mapped_triples = pykeen_GO_gene_test_triples.mapped_triples,
                                                  additional_filter_triples = [pykeen_train_triples.mapped_triples])
    convE_GO_term_evaluation = evaluator.evaluate(model = convE.model,
                                                  mapped_triples = pykeen_GO_term_test_triples.mapped_triples,
                                                  additional_filter_triples = [pykeen_train_triples.mapped_triples])
    convE_physint_evaluation = evaluator.evaluate(model = convE.model,
                                                  mapped_triples = pykeen_physint_test_triples.mapped_triples,
                                                  additional_filter_triples = [pykeen_train_triples.mapped_triples])
    convE_results = {'model': convE.model,
                     'amri': convE.get_metric('adjusted_arithmetic_mean_rank_index'),
                     'amri_pathway_relations': convE_pathway_evaluation.get_metric('adjusted_arithmetic_mean_rank_index'),
                     'amri_TF_relations': convE_GO_gene_evaluation.get_metric('adjusted_arithmetic_mean_rank_index'),
                     'amri_GO_gene_term_relations': convE_GO_gene_evaluation.get_metric('adjusted_arithmetic_mean_rank_index'),
                     'amri_GO_term_term_relations': convE_GO_term_evaluation.get_metric('adjusted_arithmetic_mean_rank_index'), 
                     'amri_physical_int_relations': convE_physint_evaluation.get_metric('adjusted_arithmetic_mean_rank_index')}
    
    pickle.dump(convE_results, open(outdir + convE_outpath, 'wb'))
    
    complEx = pipeline(
        training = pykeen_train_triples,
        testing = pykeen_test_triples,
        model = 'ComplEx',
        loss = 'MarginRankingLoss',
        optimizer = 'Adam',
        negative_sampler = 'Bernoulli',
        training_loop = 'sLCWA',
        random_seed = 123,
        **complEx_best_params
    )
    complEx_pathway_evaluation = evaluator.evaluate(model = complEx.model,
                                                    mapped_triples = pykeen_pathway_test_triples.mapped_triples,
                                                    additional_filter_triples = [pykeen_train_triples.mapped_triples])
    complEx_TF_evaluation = evaluator.evaluate(model = complEx.model,
                                               mapped_triples = pykeen_TF_test_triples.mapped_triples,
                                               additional_filter_triples = [pykeen_train_triples.mapped_triples])
    complEx_GO_gene_evaluation = evaluator.evaluate(model = complEx.model,
                                                    mapped_triples = pykeen_GO_gene_test_triples.mapped_triples,
                                                    additional_filter_triples = [pykeen_train_triples.mapped_triples])
    complEx_GO_term_evaluation = evaluator.evaluate(model = complEx.model,
                                                    mapped_triples = pykeen_GO_term_test_triples.mapped_triples,
                                                    additional_filter_triples = [pykeen_train_triples.mapped_triples])
    complEx_physint_evaluation = evaluator.evaluate(model = complEx.model,
                                                    mapped_triples = pykeen_physint_test_triples.mapped_triples,
                                                    additional_filter_triples = [pykeen_train_triples.mapped_triples])
    
    complEx_results = {'model': complEx.model,
                       'amri': complEx.get_metric('adjusted_arithmetic_mean_rank_index'),
                       'amri_pathway_relations': complEx_pathway_evaluation.get_metric('adjusted_arithmetic_mean_rank_index'),
                       'amri_TF_relations': complEx_TF_evaluation.get_metric('adjusted_arithmetic_mean_rank_index'),
                       'amri_GO_gene_term_relations': complEx_GO_gene_evaluation.get_metric('adjusted_arithmetic_mean_rank_index'),
                       'amri_GO_term_term_relations': complEx_GO_term_evaluation.get_metric('adjusted_arithmetic_mean_rank_index'),
                       'amri_physical_int_relations': complEx_physint_evaluation.get_metric('adjusted_arithmetic_mean_rank_index')}
    
    pickle.dump(complEx_results, open(outdir + complEx_outpath, 'wb'))
    
    pykeen_train.to_csv(outdir + pykeen_train_outpath, sep = '\t', index = False)
    pykeen_test.to_csv(outdir + pykeen_test_outpath, sep = '\t', index = False)
        
    custom_hp_trials = pd.read_csv(custom_trials_path, sep = '\t')
    custom_best_params = extract_best_params(custom_hp_trials, score_col = 'value')
    
    # separate learning rate from other params, make optimizer
    custom_best_model_params = {name: value for name, value in custom_best_params.items() 
                                if name != 'lr'}
    lr = custom_best_params['lr']
    optimizer = tf.keras.optimizers.Adam(learning_rate = lr)
        
    # set seed
    tf.random.set_seed(123)
    
    # train/test split
    model.split(model.embedding_data, 
                test_size = args.test_size,
                validation_size = args.validation_size,
                stratify_column = 'specific_relation_lab', 
                state = 123)
        
    # initialize model with best params
    model.initializeModel(model.embedding_facts, **custom_best_model_params, optimizer = optimizer)
    
    train, test = model.final_train_set, model.test_set
    
    # get positive facts
    negs_per_pos = 5
    pos_facts = train[['head', 'general_relation', 'specific_relation', 'tail']].to_numpy(dtype = 'int32')
    
    # get batches
    batches = model.getBatches(pos_facts)
    
    # train the model and calculate AMRI
    if gpus:
        with tf.device('/GPU:0'):
            custom_results = model.train(batches, return_results = True)
            amri = model.AMRIEvaluation(test)
    else:
        custom_results = model.train(batches, return_results=True)
        amri = model.AMRIEvaluation(test)

    custom_results['params'] = custom_best_params
    custom_results['amri'] = amri
    print('AMRI: {}'.format(amri))
    
    # calculate AMRI for pathway relations, TF binding relations, and GO gene-term/term-term relations
    test_pathway_relations = test[test['general_relation_lab'] != test['specific_relation_lab']]
    amri_pathway_relations = model.AMRIEvaluation(test_pathway_relations)
    custom_results['amri_pathway_relations'] = amri_pathway_relations
    
    test_TF_relations = test[test['general_relation_lab'] == 'TF_BINDING']
    amri_TF_relations = model.AMRIEvaluation(test_TF_relations)
    custom_results['amri_TF_relations'] = amri_TF_relations
    
    test_GO_gene_relations = test[np.logical_xor(test['head_type'] == 'GeneOntologyTerm', 
                                                 test['tail_type'] == 'GeneOntologyTerm')]
    amri_GO_gene_relations = model.AMRIEvaluation(test_GO_gene_relations)
    custom_results['amri_GO_gene_term_relations'] = amri_GO_gene_relations
    
    test_GO_term_relations = test[(test['head_type'] == 'GeneOntologyTerm') & (test['tail_type'] == 'GeneOntologyTerm')]
    amri_GO_term_relations = model.AMRIEvaluation(test_GO_term_relations)
    custom_results['amri_GO_term_term_relations'] = amri_GO_term_relations
    
    test_physint_relations = test[test['general_relation_lab'] == 'PHYSICAL_INTERACTION']
    amri_physint_relations = model.AMRIEvaluation(test_physint_relations)
    custom_results['amri_physical_int_relations'] = amri_physint_relations
        
    # save pickle
    pickle.dump(custom_results, open(outdir + custom_outpath, 'wb'))
    
    # save train/test sets
    train.to_csv(outdir + custom_train_outpath, sep = '\t', index = False)
    test.to_csv(outdir + custom_test_outpath, sep = '\t', index = False)